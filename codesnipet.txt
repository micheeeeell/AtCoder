{
    // Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
    // description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
    // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
    // same ids are connected.
    // Example:
    // "Print to console": {
    // 	"prefix": "log",
    // 	"body": [
    // 		"console.log('$1');",
    // 		"$2"
    // 	],
    // 	"description": "Log output to console"
    // }
    "vector_ll":{
        "prefix": "vl",
        "body": "vector<ll>"
    },

    "cin_vector_int":{
        "prefix": "cvi",
        "body":[
            "vector<int> $1($2);",
            "rep(i,$2) cin >> $1[i];",
        ],
        "description": "vector<int>の受取"
    },
    
    "cin_string_int":{
        "prefix": "cstr",
        "body":[
            "string $1;cin >> $1;"
        ],
        "description": "stringの受取"
    },
    "cin_2_string_int":{
        "prefix": "c2str",
        "body":[
            "string $1, $2;cin >> $1 >> $2;"
        ],
        "description": "stringの受取(2つ)"
    },

    "cin_one_int":{
        "prefix":"c1i",
        "body":[
            "int $1; cin >> $1;",
        ],
        "description":"int の受け取り（1数）"
    },
    "cin_two_int":{
        "prefix":"c2i",
        "body":[
            "int $1,$2; cin >> $1 >> $2;",
        ],
        "description":"int の受け取り（2数）"
    },
    "cin_three_int":{
        "prefix":"c3i",
        "body":[
            "int $1,$2,$3; cin >> $1 >> $2 >> $3;",
        ],
        "description":"int の受け取り（3数）"
    },
    "cin_vector_ll":{
        "prefix": "cvl",
        "body":[
            "vector<ll> $1($2);",
            "rep(i,$2) cin >> $1[i];",
        ],
        "description": "vector<ll>の受取"
    },

    "cin_two_vector_ll":{
        "prefix": "c2vl",
        "body":[
            "vector<ll> $1($3), $2($3);",
            "rep(i,$3) cin >> $1[i] >> $2[i];",
        ],
        "description": "vector<ll>二つの受取"
    },

    "cin_one_ll":{
        "prefix":"c1l",
        "body":[
            "ll $1; cin >> $1;",
        ],
        "description":"long long の受け取り（1数）"
    },
    "cin_two_ll":{
        "prefix":"c2l",
        "body":[
            "ll $1,$2; cin >> $1 >> $2;",
        ],
        "description":"long long の受け取り（2数）"
    },
    "cin_three_ll":{
        "prefix":"c3l",
        "body":[
            "ll $1,$2,$3; cin >> $1 >> $2 >> $3;",
        ],
        "description":"long long の受け取り（3数）"
    },
    "cin_graph_ll":{
        "prefix": "cgl",
        "body": [
            "vector<vector<ll>> graph($1);",
            "rep(i,$2) {",
            "\tll $3,$4;cin >> $3 >> $4;",
            "\t$3--;$4--;",
            "\tgraph[$3].emplace_back($4);",
            "\tgraph[$4].emplace_back($3);",
            "}"
        ],
        "description": "無向重みなしグラフの受け取り"
    },

    "graph_struct":{
        "prefix": "graph_struct",
        "body": [
            "template<typename T>",
            "struct edge{",
            "    int f,t;",
            "    T c;",
            "    int id;",
            "    edge(){};",
            "    edge(int f,int t,T c,int id = 0):f(f),t(t),c(c),id(id){};",
            "    bool operator< (const edge &rhs) const {",
            "        return (*this).c < rhs.c;",
            "    }",
            "    bool operator> (const edge &rhs) const {",
            "        return (*this).c > rhs.c;",
            "    }",
            "};",
            "",
            "template<typename T>",
            "struct graph{",
            "    std::vector<std::vector<edge<T> > > data;",
            "    graph(int v):data(v){};",
            "    void add_edge(edge<T> &e){",
            "        data[e.f].push_back(e);",
            "    }",
            "    void add_edge(int f,int t,T c){",
            "        data[f].emplace_back(f,t,c);",
            "    }",
            "    size_t size(){",
            "        return data.size();",
            "    }",
            "    vector<edge<T>> operator[](int n){",
            "        return data[n];",
            "    }",
            "    std::vector<edge<T>> make_edges(){",
            "        std::vector<edge<T>> r;",
            "        for(auto &i:data)std::copy(i.begin(),i.end(),std::back_inserter(r));",
            "        return r;",
            "    }",
            "};",
        ]
    },
    "include": {
        "prefix": "include",
        "body": [
            "#include<iostream>",
            "#include<cstdio>",
            "#include<vector>",
            "#include<string>",
            "#include<algorithm>",
            "#include<map>",
        ]
    },
    "include template": {
        "prefix": "itemp",
        "body": [
            "#define LOCAL",
            "#ifdef LOCAL",
            "#define _GLIBCXX_DEBUG",
            "#endif",
            "#include<bits/stdc++.h>",
            "using namespace std;",
            "#define rep(i,x) for(ll i = 0; i < (ll)(x); i++)",
            "#define rrep(i,x) for(ll i = (ll)(x)-1;0 <= i; i--)",
            "#define reps(i,x) for(ll i = 1; i < (ll)(x)+1; i++)",
            "#define rreps(i,x) for(ll i = (ll)(x); 1 <= i; i--)",
            "#define all(x) (x).begin(), (x).end()",
            "typedef long long ll;",
            "typedef long double ld;",
            "typedef pair<ll,ll> Pll;",
            "typedef vector<ll> vl;",
            "typedef vector<vl> vvl;",
            "typedef vector<vvl> vvvl;",
            "constexpr ll INF = numeric_limits<ll>::max()/4;",
            "constexpr ll n_max = 2e5+10;",
            "#define int ll",
            "",
            "template <typename A, typename B>",
            "string to_string(pair<A, B> p);",
            "string to_string(const string &s) {return '\"' + s + '\"';}",
            "string to_string(const char c) {return to_string((string) &c);}",
            "string to_string(bool b) {return (b ? \"true\" : \"false\");}",
            "template <size_t N>",
            "string to_string(bitset<N> v){",
            "    string res = \"\";",
            "    for(size_t i = 0; i < N; i++) res += static_cast<char>('0' + v[i]);",
            "    return res;",
            "}",
            "template <typename A>",
            "string to_string(A v) {",
            "    bool first = true;",
            "    string res = \"{\";",
            "    for(const auto &x : v) {",
            "        if(!first) res += \", \";",
            "        first = false;",
            "        res += to_string(x);",
            "    }",
            "    res += \"}\";",
            "    return res;",
            "}",
            "template <typename A, typename B>",
            "string to_string(pair<A, B> p){return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";}",
            "",
            "void debug_out() {cerr << endl;}",
            "template<typename Head, typename... Tail>",
            "void debug_out(Head H, Tail... T) {",
            "    cerr << \" \" << to_string(H);",
            "    debug_out(T...);",
            "}",
            "",
            "#ifdef LOCAL",
            "#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)",
            "#else",
            "#define debug(...) 42",
            "#endif\n",
            "signed main(){",
            "\tcin.tie(nullptr);",
            "\tios::sync_with_stdio(false);",
            "\t$1",
            "}"
        ],
        "description": "The template of Include library"
    },

    "print_function": {
        "prefix": "print_func",
        "body": [
            "void print() {",
            "    cout << endl;",
            "}",
            "",
            "template <class Head, class... Tail>",
            "void print(Head&& head, Tail&&... tail) {",
            "    cout << head;",
            "    if (sizeof...(tail) != 0) cout << \" \";",
            "    print(forward<Tail>(tail)...);",
            "}",
            "",
            "template <class T>",
            "void print(vector<T> &vec) {",
            "    for (auto& a : vec) {",
            "        cout << a;",
            "        if (&a != &vec.back()) cout << \" \";",
            "    }",
            "    cout << endl;",
            "}",
            "",
            "template <class T>",
            "void print(vector<vector<T>> &df) {",
            "    for (auto& vec : df) {",
            "        print(vec);",
            "    }",
            "}\n",
        ],
        "description": "print_function"
    },

    "print_vector":{
        "prefix": "print_vector",
        "body": [
            "template <class T>",
            "void print(vector<T> &vec, ll k){",
            "    ll n = vec.size();",
            "    k = min(k, n);",
            "    rep(i,k-1)cout << vec[i] << \" \";",
            "    cout << vec[k-1] << endl;",
            "}",
            "template <class T>",
            "void print(vector<vector<T>> &vec, ll k){",
            "    ll n = vec[0].size();",
            "    k = min(k, n);",
            "    for(auto &i : vec)print(i, k);",
            "}",
        ]
    },

    "ch_function":{
        "prefix": "ch_func",
        "body": [
            "template<class T>",
            "bool chmax(T &a, T b){if(a < b){a = b; return true;} return false;}",
            "template<class T>",
            "bool chmin(T &a, T b){if(a > b){a = b; return true;} return false;}"
        ]
    },

    "yes_function":{
        "prefix": "yes_func",
        "body": [
            "void YES(bool ok){",
            "\tcout << (ok ? \"Yes\" : \"No\") << endl;",
            "}",
        ]
    },

    "input_file":{
        "prefix": "input_file",
        "body": [
            "ifstream in(\"input.in\");",
            "cin.rdbuf(in.rdbuf());",
            "ofstream ofstr(\"out.txt\");",
            "streambuf* strbuf;",
            "strbuf = std::cout.rdbuf( ofstr.rdbuf() );",
        ]
    },

    "modint_container": {
        "prefix": "modint_con",
        "body": [
            "template<std::int_fast64_t Modulus>",
            "class modint {",
            "    using i64 = int_fast64_t;",
            "",
            "    public:",
            "    i64 a;",
            "",
            "    constexpr modint(const i64 x = 0) noexcept {",
            "        this -> a = x % Modulus;",
            "        if(a < 0){",
            "            a += Modulus;",
            "        }",
            "    }",
            "    constexpr int getmod() { return Modulus; }",
            "    constexpr modint operator - () const noexcept {",
            "        return a ? Modulus - a : 0;",
            "    }",
            "    constexpr const i64 &value() const noexcept {return a;}",
            "    constexpr modint operator+(const modint rhs) const noexcept {",
            "        return modint(*this) += rhs;",
            "    }",
            "    constexpr modint operator-(const modint rhs) const noexcept {",
            "        return modint(*this) -= rhs;",
            "    }",
            "    constexpr modint operator*(const modint rhs) const noexcept {",
            "        return modint(*this) *= rhs;",
            "    }",
            "    constexpr modint operator/(const modint rhs) const noexcept {",
            "        return modint(*this) /= rhs;",
            "    }",
            "    constexpr modint &operator+=(const modint rhs) noexcept {",
            "        a += rhs.a;",
            "        if(a >= Modulus) {",
            "            a -= Modulus;",
            "        }",
            "        return *this;",
            "    }",
            "    constexpr modint &operator-=(const modint rhs) noexcept {",
            "        if(a < rhs.a) {",
            "            a += Modulus;",
            "        }",
            "        a -= rhs.a;",
            "        return *this;",
            "    }",
            "    constexpr modint &operator*=(const modint rhs) noexcept {",
            "        a = a * rhs.a % Modulus;",
            "        return *this;",
            "    }",
            "    constexpr modint &operator/=(modint rhs) noexcept {",
            "        i64 a_ = rhs.a, b = Modulus, u = 1, v = 0;",
            "        while(b){",
            "            i64 t = a_/b;",
            "            a_ -= t * b; swap(a_,b);",
            "            u -= t * v; swap(u,v);",
            "        }",
            "        a = a * u % Modulus;",
            "        if(a < 0) a += Modulus;",
            "        return *this;",
            "    }",
            "    ",
            "    // 自前実装",
            "    constexpr bool operator==(const modint rhs) noexcept {",
            "        return a == rhs.a;",
            "    }",
            "    constexpr bool operator!=(const modint rhs) noexcept {",
            "        return a != rhs.a;",
            "    }",
            "    constexpr bool operator>(const modint rhs) noexcept {",
            "        return a > rhs.a;",
            "    }",
            "    constexpr bool operator>=(const modint rhs) noexcept {",
            "        return a >= rhs.a;",
            "    }",
            "    constexpr bool operator<(const modint rhs) noexcept {",
            "        return a < rhs.a;",
            "    }",
            "    constexpr bool operator<=(const modint rhs) noexcept {",
            "        return a <= rhs.a;",
            "    }",
            "    constexpr modint& operator++() noexcept {",
            "        return (*this) += modint(1);",
            "    }",
            "    // constexpr modint operator++(int) {",
            "    //     modint tmp(*this);",
            "    //     operator++();",
            "    //     return tmp;",
            "    // }",
            "    constexpr modint& operator--() noexcept {",
            "        return (*this) -= modint(1);",
            "    }",
            "    // constexpr modint operator--(int) {",
            "    //     modint tmp(*this);",
            "    //     operator--();",
            "    //     return tmp;",
            "    // }",
            "    template<typename T>",
            "    friend constexpr modint modpow(const modint &mt, T n) noexcept {",
            "        if(n < 0){",
            "            modint t = (modint(1) / mt);",
            "            return modpow(t, -n);",
            "        }",
            "        modint res = 1, tmp = mt;",
            "        while(n){",
            "            if(n & 1)res *= tmp;",
            "            tmp *= tmp;",
            "            n /= 2;",
            "        }",
            "        return res;",
            "    }",
            "};",
            "",
            "const ll MOD = 1e9+7;",
            "using mint = modint<MOD>;",
            "// 標準入出力対応",
            "std::ostream &operator<<(std::ostream &out, const modint<MOD> &m) {",
            "    out << m.a;",
            "    return out;",
            "}",
            "std::istream &operator>>(std::istream &in, modint<MOD> &m) {",
            "    ll a;",
            "    in >> a;",
            "    m = mint(a);",
            "    return in;",
            "}",
            ""
        ],
        "description": "modint_container"
    },

    "bicoef": {
        "prefix": "bicoef",
        "body": [
            "template<class T> struct BiCoef {",
            "    vector<T> fact_, inv_, finv_;",
            "    constexpr BiCoef() {}",
            "    constexpr BiCoef(int n) noexcept : fact_(n, 1), inv_(n, 1), finv_(n, 1) {",
            "        init(n);",
            "    }",
            "    constexpr void init(int n) noexcept {",
            "        fact_.assign(n, 1), inv_.assign(n, 1), finv_.assign(n, 1);",
            "        int MOD = fact_[0].getmod();",
            "        for(int i = 2; i < n; i++){",
            "            fact_[i] = fact_[i-1] * i;",
            "            inv_[i] = -inv_[MOD%i] * (MOD/i);",
            "            finv_[i] = finv_[i-1] * inv_[i];",
            "        }",
            "    }",
            "    constexpr T com(int n, int k) const noexcept {",
            "        if (n < k || n < 0 || k < 0) return 0;",
            "        return fact_[n] * finv_[k] * finv_[n-k];",
            "    }",
            "    constexpr T fact(int n) const noexcept {",
            "        if (n < 0) return 0;",
            "        return fact_[n];",
            "    }",
            "    constexpr T inv(int n) const noexcept {",
            "        if (n < 0) return 0;",
            "        return inv_[n];",
            "    }",
            "    constexpr T finv(int n) const noexcept {",
            "        if (n < 0) return 0;",
            "        return finv_[n];",
            "    }",
            "};",
            "",
            "BiCoef<mint> bc(n_max);",
        ]
    },
    "grid_template": {
        "prefix": "grid_temp",
        "body": [
            "ll dx[] = {0,0,1,-1};",
            "ll dy[] = {1,-1,0,0};",
            "auto is_out = [&](ll x, ll y){",
            "   if(x < 0 || x >= h || y < 0 || y >= w)return true;",
            "   return false;",
            "};"
        ]
    },
    "clock_time": {
        "prefix": "clock",
        "body": [
            "clock_t start = clock();",
            "",
            "// 何らかの処理",
            "",
            "clock_t end = clock();",
            "",
            "const double time = static_cast<double>(end - start) / CLOCKS_PER_SEC * 1000.0;",
            "printf(\"time %lf[ms]\n\", time);",
        ]
    },
}